{"version":3,"file":"react-router-config-upgrade.min.js","sources":["../../modules/matchRoutes.tsx","../../modules/query.ts","../../modules/renderRoutes.tsx","../../modules/index.ts"],"sourcesContent":["import { Router, matchPath, match } from \"react-router\";\nimport { RouteConfig, MatchedRoute } from \"./types\";\n\nfunction computeRootMatch<Params extends { [K in keyof Params]?: string } = {}>(\n  pathname: string\n): match<Params | {}> {\n  return {\n    path: \"/\",\n    url: \"/\",\n    params: {},\n    isExact: pathname === \"/\",\n  };\n}\n\nfunction matchRoutes<Params extends { [K in keyof Params]?: string } = {}>(\n  routes: RouteConfig[],\n  pathname: string,\n  branch: Array<MatchedRoute<Params | {}>> | undefined = []\n): Array<MatchedRoute<Params | {}>> {\n  routes.some((route) => {\n    const match: match<Params | {}> | null = route.path\n      ? matchPath(pathname, route)\n      : branch.length\n      ? branch[branch.length - 1].match\n      : computeRootMatch(pathname);\n\n    if (match) {\n      branch.push({ route, match });\n\n      if (route.routes) {\n        matchRoutes<Params>(route.routes, pathname, branch);\n      }\n    }\n\n    return match;\n  });\n\n  return branch;\n}\n\nexport default matchRoutes;\n","import qs from 'qs';\n\nconst queryMap: { [key: string]: any } = {};\n\nexport default function getQueryParamFromLocation(location: { search: string }) {\n  if (!queryMap[location.search]) {\n    const result = JSON.stringify(qs.parse(location.search.slice(1)));\n    queryMap[location.search] = new Function(`return ${result}`);\n  }\n  return queryMap[location.search]();\n}","import React from \"react\";\nimport { Switch, Route, SwitchProps } from \"react-router\";\nimport { RouteComponentProps, Redirect } from \"react-router-dom\";\nimport { LocationDescriptor } from \"history\";\nimport { RouteConfig, RedirectFunction } from \"./types\";\n\nimport getQueryParamFromLocation from \"./query\";\n\n/**\n * 如果path 以/结尾 或根路由就是 /，那么如果直接拼接\n * 路由会变成 xxx//xxx 所以在此format一下\n * @param path\n */\nfunction formatPath(path: string): string {\n  if (path.endsWith(\"/\")) {\n    return formatPath(path.slice(0, -1));\n  } else {\n    return path;\n  }\n}\n\n/**\n * 判断是否为一个function\n * @param fn\n */\nfunction isFunction(fn: LocationDescriptor | Function): boolean {\n  return Object.prototype.toString.call(fn) === \"[object Function]\";\n}\n\nfunction generateRoute(route: RouteConfig): RouteConfig {\n  const parentRoute: RouteConfig = { ...route };\n\n  const parentPaths: string[] = Array.isArray(parentRoute.path)\n    ? parentRoute.path\n    : parentRoute.path\n    ? [parentRoute.path]\n    : [];\n\n  if (parentRoute.routes) {\n    parentRoute.routes = parentRoute.routes.map((childRoute) => {\n      const childrenPaths: string[] = Array.isArray(childRoute.path)\n        ? childRoute.path\n        : childRoute.path\n        ? [childRoute.path]\n        : [];\n\n      const resultPaths: string[] = [];\n\n      // 循环计算此层路由 可能会出现的 path 因为 parent 和 child 都有可能是 [] 多个\n      childrenPaths.forEach((childPath: string) => {\n        parentPaths.forEach((parentPath: string) => {\n          resultPaths.push(`${formatPath(parentPath)}${childPath}`);\n        });\n      });\n\n      return {\n        ...childRoute,\n        path: resultPaths.length <= 1 ? resultPaths[0] : resultPaths,\n      };\n    });\n  }\n\n  return parentRoute;\n}\n\n// 渲染子路由方法\nfunction renderRoutes(\n  routes: RouteConfig[],\n  extraProps: any | undefined = {},\n  switchProps: SwitchProps | undefined = {}\n): React.ReactNode {\n  return routes ? (\n    <Switch {...switchProps}>\n      {routes.map((_route, index) => {\n        // 计算子路由 parentPath + childPath\n        // 使配置参数可以不需要给出完整路径 该方法会自动计算出\n        const route = generateRoute(_route);\n\n        const {\n          key,\n          path,\n          exact,\n          strict,\n          sensitive,\n          location,\n          redirect,\n          component: Component,\n          fallback,\n          render,\n          ...others\n        } = route;\n        return (\n          <Route\n            key={key || index}\n            path={path}\n            exact={exact}\n            strict={strict}\n            sensitive={sensitive}\n            location={location}\n            {...others}\n            render={(props: RouteComponentProps) => {\n              const extendedProps = {\n                ...props,\n                location: {\n                  ...props.location,\n                  query: getQueryParamFromLocation(\n                    props.location || { search: \"\" }\n                  ),\n                },\n                route,\n              };\n\n              if (redirect) {\n                // 重定向 这里的redirect 应该是 完全路径\n                // 因为 在 上级 path是[]时\n                // redirect 应该重定向到数组里的哪个父路由下 其实是比较难确定的\n                // 且如果 由 此层路由 跳往 它层路由 也是实现不了的 故而 是个 完全路径\n                let to: LocationDescriptor = \"\";\n                if (isFunction(redirect)) {\n                  to = (redirect as RedirectFunction)({\n                    ...extraProps,\n                    ...extendedProps,\n                  });\n                } else {\n                  to = redirect as LocationDescriptor;\n                }\n                return (\n                  // 加了switch 才能在 Route 下 的 Redirect 能传递params\n                  <Switch>\n                    <Redirect from={props.match.path} to={to} />\n                  </Switch>\n                );\n              } else if (Component) {\n                const { location } = props;\n                if (React.Suspense && fallback) {\n                  // 如果是 lazyload 组件 需要给出fallback参数以生效lazy效果\n                  return (\n                    <React.Suspense fallback={fallback || <div>loading</div>}>\n                      <Component {...extraProps} {...extendedProps} />\n                    </React.Suspense>\n                  );\n                } else {\n                  return <Component {...extraProps} {...extendedProps} />;\n                }\n              } else if (render) {\n                if (React.Suspense && fallback) {\n                  // 如果是 lazyload 组件 需要给出fallback参数以生效lazy效果\n                  return (\n                    <React.Suspense fallback={fallback || <div>loading</div>}>\n                      {render({\n                        ...extraProps,\n                        ...extendedProps,\n                      })}\n                    </React.Suspense>\n                  );\n                } else {\n                  return render({\n                    ...extraProps,\n                    ...extendedProps,\n                  });\n                }\n              }\n\n              return null;\n            }}\n          />\n        );\n      })}\n    </Switch>\n  ) : null;\n}\n\nexport default renderRoutes;\n","export {default as matchRoutes} from './matchRoutes';\nexport {default as getQueryParamFromLocation} from './query';\nexport {default as renderRoutes} from './renderRoutes';\n\nexport * from './types';\n\nimport React, {FunctionComponent, ComponentClass} from 'react';\nimport {withRouter as _withRouter, RouteComponentProps, Link, NavLink, HashRouter, BrowserRouter, Router, Route, Redirect, Switch, matchPath, useRouteMatch, useHistory, useLocation, useParams} from 'react-router-dom';\n\nimport getQueryParamFromLocation from './query';\n\nexport function withRouter(Comp: FunctionComponent|\n                           ComponentClass<RouteComponentProps>) {\n  return _withRouter((props) => {\n    const location = props.location;\n    return React.createElement(Comp as any, {\n      ...props,\n      location: {...location, query: getQueryParamFromLocation(location)}\n    });\n  });\n}\n\nexport {\n  Link,\n  NavLink,\n  HashRouter,\n  BrowserRouter,\n  Router,\n  Route,\n  Redirect,\n  Switch,\n  matchPath,\n  useRouteMatch,\n  useHistory,\n  useLocation,\n  useParams\n}"],"names":["computeRootMatch","pathname","path","url","params","isExact","matchRoutes","routes","branch","some","route","match","matchPath","length","push","queryMap","getQueryParamFromLocation","location","search","result","JSON","stringify","qs","parse","slice","Function","formatPath","endsWith","isFunction","fn","Object","prototype","toString","call","generateRoute","parentRoute","parentPaths","Array","isArray","map","childRoute","childrenPaths","resultPaths","forEach","childPath","parentPath","renderRoutes","extraProps","switchProps","React","Switch","_route","index","key","exact","strict","sensitive","redirect","Component","component","fallback","render","others","Route","props","extendedProps","query","to","Redirect","from","Suspense","withRouter","Comp","_withRouter","createElement"],"mappings":"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"}